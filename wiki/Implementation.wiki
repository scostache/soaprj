#summary HybFS and additional modules implementation details
#labels Phase-Implementation
#sidebar Contents

== HybFS Implementation ==

The implementation of the HybFS filesystem consists of three modules grouped togheter in one application. There is the frontend FUSE filesystem (also called "the hybfs core") and a backend comprising of a parser and the Berkley Database storage used for keeping the tag-files associations. The abstract flow of a request (or user operation) can be seen in the following diagram. The HybFS core interface makes the appropiate calls to the parser, the database and the underlying filesystem. The interface offered to the user processes remains unmodified.

http://soaprj.googlecode.com/svn/wiki/diagrama.jpeg

 # A file system operation is issued (think of create, rename, unlink, etc.) and is passed to the HybFS filesystem. 
 # The provided path is analyzed and validated by _the query parser_ and the results are packed in an internal representation used afterwards to issue operations to the database backend.
 # The metadata from the main database is accesed and/or modified.
 # The results are returned to the HybFS core.
 # Based on the results obtained, and if needed, the core interface issues a series of operations to the underlying filesystem(s).

=== Technologies ===

 # *FUSE* (File system in user space) - an abstraction layer that allows a fully functional file system to be written in user space, and allows
 regular users to mount file systems. It provides a simple and efficient API for rapid development.

 # *Sqlite3* - an Open Source embedded database library.

 # C/C++ - for the filesystem implementation
 # C++ with (possibly) GTK+ for the policy management framework


=== Frontend ===

The filesystem can be mounted over a directory specified at mount time. When accesing the mount point, the user will be able to issue queries. In the first stage we only mirrored the original directory in the mount point. Next, we added support for BDB (Berkeley Database) and the implementation of file operations based on tags is still in progress.

=== Backend ===

==== Query Parser ====

For the parser we used Lemon.

==== Interface with the Sqlite Database ====

Sqlite is linked in the application as a library. For now we set three tables that contains primary information about the tagged files. We designed a table for storing information about the file ino (this should change), the mode and the real path relative to the mounted directory; another one for storing the tag and value pairs, togheter with an unique id and the last one keeps the association between a file id and a tag:value id. Also, for simple tags (that don't have a value), we assign the "null" value.
The metadata directory is set in each mount point (branch), with the name _.hybfs_ . Theoreticaly, almost all the files created by Sqlite reside there. The main database is kept in the file .hybfs_main.db .

-----------------------------------------------------------------------------------------------------------------------------------

=== Policy Framework ===

The policy framework will provide an interface to define different tagging behaviours for the different mounted directories. This will allow the user to tag automatically files based on their types and the existing supported tagging modules (the first stage will be to extract information for MP3's or JPEG files).



