#summary Wiki page for our project
#labels Featured,Phase-Design,Phase-Implementation

<wiki:toc max_depth="3" />

--------------------------------------------------------------------------------------


== Project overview ==

HybFS is an _almost_ semantic file system on Linux that can be overlaid on other file systems and provide multiple organizational views of the same original hierarchy of files, without altering the interface for the existing applications. 
This is realized by associating multiple _tags_ with files. A user can create and assign many tags to a file or groups of files containing other tags. The browsing and file operations can be done by using the concept of _virtual_ _directory_. We can think of a virtual directory as a combination of tags, using logic operators like disjunction, conjunction or negation. This will also be known as a _query_.

We mentioned that HybFS is an _almost_ semantic file system, because it actually represents a compromise between the hierarchic and semantic file systems. 


The user can organize files in a hierarchic way, but in the same time can assign tags, or keywords, to the files. In the end the user will have multiple 
This file system comes with two view perspectives to the user:
  # Hierarchic view of the files
  # Semantic view of the files


===Primary aims===

For having a basic functionality, we define the following set of aims that must be completed during the allocated time:
 # Implement operations on simple tags and tags with values. A user can create, modify or delete the tags associated to a file.
 # Implement support for queries based on multiple tags.
 # Mount the semantic file system on top of multiple directories (support multiple branches), regardless of the underlying file system(s), thus offering a unified view based on file metadata.
 # Allow operations on sets of files, identified by combinations of tags, also known as queries (for example: delete or move all files corresponding to a query, from the underlying file systems).



=== Secondary aims ===

Having considered the limited time, we established a number of features with a lower priority. Still, these are desirable to have, in order to show the potential of a semantic file system.
 # Add semantic transducers to automatically extract metadata from new files.
 # Add metadata extraction/management policies for each mounted directory/branch, so that new files will be automatically labeled with the set of extracted keywords. As a proof-of-concept, this will be done for MP3 and EXIF metadata.
 # Create a separate application for a user-friendly policy management.
 # Create a set of scripts to automatically index files by adding the corresponding tags to the file system metadata - used for testing.


=== Resources ===
 * FUSE - We decided that for our file system implementation we should use the FUSE API, because it allows a rapid development. Also, we want to allow regular users to mount and configure our file system. 
 * Berkley DB - For storing the associated meta-data we use the Berkley DB, an Open Source embedded database engine that can be linked directly into an application.

----------------------------------------------------------------------------------------

== How is meta-information defined in HybFS ==

Each file can be described by using one or multiple tags. A tag represents an additional attribute set by the user. The tags can be simple, or have an associated value.

*Simple tags* are specific keywords added to describe a file. The *attribute-value* tags  are used to granulate even more the description. In this case, the attribute represents the criteria of description and the value is the subcategory. 
Ex: _the file_ *photo1.jpg* _can have as simple tags_ *holiday* _and_ *ski* _, and as attribute-value tags_ *year:2005* _,_ *author:stefania* _and_ *type:jpeg*.

To find the file from the above example, we can specify a path that can be a combination of *holiday* or/and *ski*. To further differentiate between the results of this query, we can also mention the value *2005* for the tag *year* .

In order for the user to have also a hierarchic view, all files in the HybFS have 2 special attribute-value tags:
  * path:file_path (file path without the filename)
  * filename:file_name (the exact file name as in the hierarchic file system)

----------------------------------------------------------------------------------------

== Semantics of HybFS operations ==

The navigation in HybFS resembles the navigation through a normal hierarchic file system, except the path is in fact a *query* on the tag information associated with the files. From the application point of view, the hierarchic file system operations remain unchanged when using HybFS. 

=== Meta Information ===

The commands remain unchanged, but all this comes with a price: the files in our system can't use the following characters:
  * *(*
  * *)*
  * *:*
  * *+*
  * *|*
  * *!*

These characters are needed to form the queries on semantic information.

=== Query syntax ===

The queries will support the following logic operators:
  * *+* - logic *AND*
  * *|* - logic *OR*
  * *!* - logic *NOT*

Beside logic operators, brackets can be used for more complicated queries.

Ex: *ls (type:photo + year:2005) + (!ski + !snowboard)* - will display all files that have the tag *type:photo* and *year:2005*, but they don't have *ski* and *snowboard* tags.



=== Files/directories operations ===

Our objective here is to keep the same interface as for the hierarchic file system operations and in the same time to seamlessly add semantic operations.

Concerning *navigation*, the system will be *2-Dimensional*:
  * the current folder as we all know it in hierarchical file systems
  * the current folder (virtual folder), which is in fact a *query*

HybFS does not permit file names with *'('* and *')'*, because when of the existence of complex queries that need brackets. If the path is between brackets, it will be interpreted as a query, otherwise a simple file path relative to the hierarchic file system.


==== File listing ====

All files will be listed based on a query (if a query exists). If there are no semantic queries, the behavior will be the same as in a hierarchic file system.

ex: *ls (type:photo + year:2005)* will list:
*ski* *holiday* *summer* _photoComposition-2005.jpg_

*ski, holiday* and *summer* being virtual directories and *photoComposition-2005.jpg* being a file. What does this output stands for? The command was issued to list all files that have *type:photo* and *year:2005* tags. The file *photoComposition-2005.jpg* has only these 2 tags set. But there are files that have other tags too, like *holiday*, *summer* or *ski*. These files are grouped in *virtual folders* which have the name of the remaining tags (tags that were not included in the query). 

Why not just listing all files that have *type:photo* and *year:2005* tags. Well, one of the drawbacks of full semantic file systems is that there the user doesn't receive any suggestions when navigating through the files. He has to know what he is looking for. In our example, when he looks for files that are *photos* and have been taken in *2005*, he may not know that these files have other tags also and can be filtered even more.


==== File rename ====
==== File remove ====
==== File creation ====
==== Directory operations ====

=== Tags operations ===

---------------------------------------------------------------------------------------

== Bibliography ==

(semantic file systems)

1. M. A. Sheldon, D. K. Gifford, P. Jouvelot and et. al. Semantic file systems.

2. D. Giampaolo. Practical file system design with the Be file system.

3. S. Bloehdorn. Tagfs - tag semantics for hierarchical file systems.

4. Y. Padioleau, O. Ridoux. A logic file system.

6. David Ingram. Insight: A semantic file system.

7. M. Mahalingam, C. Tang, Z. Xu. Towards a semantic, deep archival file system.

8. A. Ames, N. Bobb, S. A. Brandt and et. al. Richer file system metadata using links and attributes.

9. Spotlight - http://en.wikipedia.org/wiki/Spotlight_(software)

10. WinFS - http://en.wikipedia.org/wiki/Winfs

(design considerations)

11. A. Kashyap. File system extensibility and reliability using an in-kernel database.

12. J. Sipek, Y. Pericleous, and E. Zadok. Kernel support for stackable file systems.

13. E. Zadok and J. Nieh. FiST: a language for stackable file systems.

14. E. Zadok, I. Badulescu and A. Shender. Extending file systems using stackable templates.

15. D. Quigley, J. Sipek, C. P. Wright and et. al. Unionfs: user- and community-oriented development of a unification file system.

16. FUSE: Filesystem in Userspace - http://fuse.sourceforge.net/

17. Richard P. Spillane, Charles P. Wright, G. Sivathanu and et. al. Rapid file system development using ptrace.

(Somehow unrelated):
 A. Muthitacharoen, R. Morris, T. M. Gil, and B. Chen. Ivy: A Read/Write Peer-to-Peer File System.