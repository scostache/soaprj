#summary Wiki page for our project
#labels Featured,Phase-Design,Phase-Implementation

<wiki:toc max_depth="3" />



== Project overview ==

 HybFs is an _almost_ semantic file system on Linux that can be overlaid on other file systems and provide multiple organizational views of the same original hierarchy of files, without changing the original structure or altering the interface for the existing applications. 
This is realized by associating multiple _tags_ with files. A user can create and assign many tags to a file, directory or groups of files containing other tags. The browsing and file operations can be done by specifying _queries_ instead of the file path. A query, represented as a _virtual directory_, is a combination of tags, using logic operators like disjunction, conjunction or negation.

HybFS is a compromise between the hierarchic and semantic file systems. The user can organize files in a hierarchic way, but in the same time can assign tags, or keywords, to the files. This file system comes with two view perspectives to the user:
  # Hierarchic view of the files
  # Semantic view of the files


===Primary aims===

For having a basic functionality, we define the following set of aims that must be completed during the allocated time:
 # Implement support operations on simple tags and tags with values. A user can create, modify or delete the tags associated to a file.
 # Implement support queries based on multiple tags.
 # Mount the semantic file system on top of multiple directories (support multiple branches), regardless of the underlying file system(s), thus offering a unified view based on file metadata.
 # Allow operations on sets of files, identified by combinations of tags, also known as queries (for example: delete or move all files corresponding to a query).



=== Secondary aims ===

Having considered the limited time, we established a number of features with a lower priority. Still, these are desirable to have, in order to show the potential of a semantic file system.
 # Add semantic transducers to automatically extract metadata from new files.
 # Add metadata extraction/management policies for each mounted directory/branch, so that new files will be automatically labeled with the set of extracted keywords. As a proof-of-concept, this will be done for MP3 and EXIF metadata.
 # Create a separate application for a user-friendly policy management.
 # Create a set of scripts to automatically index files by adding the corresponding tags to the file system metadata - used for testing.


=== Resources ===
 * FUSE - We decided that for our file system implementation we should use the FUSE API, because it allows a rapid development. Also, we want to allow regular users to mount and configure our file system. 
 * Berkley DB - For storing the associated meta-data we use the Berkley DB, an Open Source embedded database engine that can be linked directly into an application.



== How is meta-information defined in HybFS ==

Each file can be described using one or multiple tags. A tag is regarded as an attribute for the file. 
Now, the file can be described by two types of tags:
  # Simple tags
  # Attribute-value associations

*Simple tags* are attributes that can be added to describe a file. As for *attribute-vale* tags, they are used to granulate even more the description for a file. The attribute is criteria of description the and the value is the subcategory.

Ex: _the file_ *photo1.jpg* _can have as simple tags_ *holiday* _and_ *ski* _, and as for the attribute-value tags_ *year:2005* _,_ *author:stefania* _and_ *type:jpeg*.

In the example above, the file *photo1.jpg* has 2 simple tags: *holiday* and *ski*. To find this file, the user can search for the files that have *holiday* or *ski* defined as keywords. But, there can a lot of files that have defined as tags *ski* and *holiday*. The file has also defined some _attribute-value_ tags. The first tag, *year:2005* sets an attribute *year* with the value *2005*. This makes it easier for the user to categorize files using tags. Instead of defining only simple tags, he can define simple, clear attributes that permit to differentiate between files.



In order for the user to have also a hierarchic view, all files in the HybFS have 2 special attribute-value tags:
  * path:file_path (file path without the filename)
  * filename:file_name (the exact file name as in the hierarchic file system)

== Semantics of HybFS operations ==

The navigation in HybFS resembles the navigation through a normal hierarchic file system, except the path is in fact a *query* on the tag information associated with the files.
The hierarchic file system shell operations remain unchanged for HybFS. The only difference is that you can provide a *query* instead of a *file path*.

=== Meta Information ===
The commands remain unchanged, but all this comes with a price: the files in our system can't use the following characters:
  * *(*
  * *)*
  * *:*
  * *+*
  * *|*
  * *!*

These characters are needed to form the queries on semantic information.

=== Query syntax ===

The queries will support the following logic operators:
  * *+* - logic *AND*
  * *|* - logic *OR*
  * *!* - logic *NOT*

Beside logic operators, brackets can be used for more complicated queries.

Ex: *ls (type:photo + year:2005) + (!ski + !snowboard)* - will display all files that have the tag *type:photo* and *year:2005*, but they don't have *ski* and *snowboard* tags.



=== Files/directories operations ===

Our objective here is to keep the command syntax for the hierarchic file system commands and in the same time to seamlessly add semantic operations.

Concerning *navigation*, the system will be *2-Dimensional*:
  * the current folder as we all know it in hierarchical file systems
  * the current folder (virtual folder), which is in fact a *query*

HybFS does not permit file names with *'('* and *')'*, so the all queries are between brackets. If the path is between brackets, it will be interpreted as a query, otherwise a simple file path relative to the hierarchic file system.


==== File listing ====

All files will be listed based on a query (if a query exists). If there are no semantic queries, the behaviour will be the same as in a hierarchic file system.

ex: *ls (type:photo + year:2005)* will list:
*ski* *holiday* *summer* _photoComposition-2005.jpg_

*ski, holiday* and *summer* being virtual directories and *photoComposition-2005.jpg* being a file. What does this output stands for? The command was issued to list all files that have *type:photo* and *year:2005* tags. The file *photoComposition-2005.jpg* has only these 2 tags set. But there are files that have other tags too, like *holiday*, *summer* or *ski*. These files are grouped in *virtual folders* which have the name of the remaining tags (tags that were not included in the query). 

Why not just listing all files that have *type:photo* and *year:2005* tags. Well, one of the drawbacks of full semantic file systems is that there the user doesn't receive any suggestions when navigating through the files. He has to know what he is looking for. In our example, when he looks for files that are *photos* and have been taken in *2005*, he may not know that these files have other tags also and can be filtered even more.


==== File rename ====
==== File remove ====
==== File creation ====
==== Directory operations ====

=== Tags operations ===

== Bibliography ==

(semantic file systems)

1. M. A. Sheldon, D. K. Gifford, P. Jouvelot and et. al. Semantic file systems.

2. D. Giampaolo. Practical file system design with the Be file system.

3. S. Bloehdorn. Tagfs - tag semantics for hierarchical file systems.

4. Y. Padioleau, O. Ridoux. A logic file system.

6. David Ingram. Insight: A semantic file system.

7. M. Mahalingam, C. Tang, Z. Xu. Towards a semantic, deep archival file system.

8. A. Ames, N. Bobb, S. A. Brandt and et. al. Richer file system metadata using links and attributes.

9. Spotlight - http://en.wikipedia.org/wiki/Spotlight_(software)

10. WinFS - http://en.wikipedia.org/wiki/Winfs

(design considerations)

11. A. Kashyap. File system extensibility and reliability using an in-kernel database.

12. J. Sipek, Y. Pericleous, and E. Zadok. Kernel support for stackable file systems.

13. E. Zadok and J. Nieh. FiST: a language for stackable file systems.

14. E. Zadok, I. Badulescu and A. Shender. Extending file systems using stackable templates.

15. D. Quigley, J. Sipek, C. P. Wright and et. al. Unionfs: user- and community-oriented development of a unification file system.

16. FUSE: Filesystem in Userspace - http://fuse.sourceforge.net/

17. Richard P. Spillane, Charles P. Wright, G. Sivathanu and et. al. Rapid file system development using ptrace.

(Somehow unrelated):
 A. Muthitacharoen, R. Morris, T. M. Gil, and B. Chen. Ivy: A Read/Write Peer-to-Peer File System.