#summary This page presents the design and functionality of HybFS
#labels Phase-Design
#sidebar Contents

<wiki:toc max_depth="3" />

----------------------------------------------------------------------------------------

= HybFS meta-information =

Each file can be described by using one or multiple tags. A tag represents an additional attribute set by the user. The tags can be simple, or have an associated value.

*Simple tags* are specific keywords added to describe a file. The *attribute-value* tags  are used to granulate even more the description. In this case, the attribute represents the criteria of description and the value is the subcategory. 
Ex: _the file_ *photo1.jpg* _can have as simple tags_ *holiday* _and_ *ski* _, and as attribute-value tags_ *year:2005* _,_ *author:stefania* _and_ *type:jpeg*.

Also, a file can have a general tag (without a value associated) and some other files can have the same tag, but with some values. 
Ex: suppose we have the file *fruits.jpg* and we assign the tag *apple*, because it contains some nice representations of this kind of fruit. Also, we
can have a *receipt.doc* with the tag  *apple:sweet*, because it describes some apple pie receipt and it uses sweet apples.

To find the files from the above example, we can specify a path that can be a combination of multiple tags with or without associated values.

In order for the user to have also a hierarchic view, all files in the HybFS have assigned the special tag *path* with the value representing
the file path.

----------------------------------------------------------------------------------------

= HybFS semantics =

The navigation in HybFS resembles the navigation through a normal hierarchic file system, except the path is in fact a *query* on the tag information associated with the files. From the application point of view, the file system operations remain unchanged when using HybFS. 

== Query syntax ==

The queries will support the following logic operators:
  * *+* - logic *AND*
  * *|* - logic *OR*
  * *!* - logic *NOT*

Beside logic operators, brackets can be used for more complicated queries.

Ex: *ls '(type:photo + year:2005) + (!ski + !snowboard)'* - will display all files that have the tag *type:photo* and *year:2005*, but they don't have *ski* and *snowboard* tags.

A query must be supplied by using the sepparators '(' and ')', otherwise it will be considered illegal. Also, we can provide a normal navigation
through the original hierarchy, by using the special virtual directory *path:* .

== HybFS operations ==

Our objective here is to keep the same interface as for the hierarchic file system operations and in the same time to seamlessly add semantic operations.

Concerning *navigation*, the system will be *2-Dimensional*:
  * the current path from the hierarchical file system(s) or:
  * the current virtual folder, which retains the current query


=== File listing ===

All files will be listed based on a query (if a query exists). If there are no semantic queries and the path is specified by using the special directory
*path:*, the behavior will be the same as in a hierarchic file system.

One of the possible drawbacks of full semantic file systems is that the user doesn't receive any suggestions when navigating through the files and it has to know what is looking for. This was solved by adding virtual folders to refine the results of the navigation. In our example, when we look for files that are *photos* and have been taken in *2005*, we may not know that these files have other tags also and can be filtered even more. Further more, by having this extra information we can discover other files that share the same information/tags as the listed ones. 

Example: 
Suppose that we want to list all files  that have the *year:2005* tag:
{{{ 
ls '/(year:2005)'
}}}
The output will be something like:
{{{ 
(ski)/ (holiday)/ (summer)/ photoComposition-2005.jpg 
}}}

where *ski, holiday* and *summer* are virtual directories and *photoComposition-2005.jpg* is a file. Suposing that the file *photoComposition-2005.jpg* has besides these two tags, the keywords _ski, holiday and summer_. Even if they weren't included in the query, they are still listed. 


=== File rename ===

The renaming of files keeps the usual syntax and it can be used also for operations on tags.

Example:
To rename the file *photo1.jpg* as *first_photo.jpg*, one can identify in a unique way the source and the destination by specifing the values for the special tag _path_ : 
{{{
mv /path:/directory/photo1.jpg /path:/directory/path/first_photo.jpg
}}}
or it can specify a set of files determined by combinations of tags, to be moved in another directory, and other tags to be assignated:
{{{
mv '/(ski + holiday)' '/path:/pictures/alps/(alps)'
}}}


=== Replace tags ===

This operation is done using the rename operation, but this time applied to tags only. With this operation, all the tags from the files depicted by the source query are removed, new tags being added by specifying them in the destination query. This will tell which are the tags that will replace the original ones. Also, the query that specifies the new tags to be assigned must be based on conjunctions only. This is happening because a different sintax will be too ambiguous. 

Example:
For all the files that have the *type:photo* and *author:stefania* tags defined, we want to delete all the other tags and transform the *type:photo* into *type:jpg*. This operation can be done as following:  
{{{
mv '/(type:photo + author:stefania)' '/(type:jpg)'
}}}

Remember, if there is no real path specified, with the "/path:/" prefix, no real rename of the files will be performed.


=== File remove ===

In order to actually remove a file, you can use a query to point out the files based on tag information. All files resulted from the query will be deleted along with their tag information from the DB.

=== File creation ===

If someone wants to create a file, than the real path with the prefix */path:/* must be specified. Also, to add tags at creation time, they must be specified in (only) a conjunction query.

=== Add/Remove tags ===

This can be done by using the rename operation. Also, the tags can be specified at creation.
Example:
To add the tags _alps_ and _ski_ to the file /directory/path/photo1.jpg :
{{{
mv /path:/directory/path/photo1.jpg '/(alps+ski)'
}}}

Remember to specify an absolute query, because if it's relative, it will be appended to the current query! This can result in an invalid query!


-------------------------------------------------------------------------------------------------------------------------------

= Known limitations and issues =

 # Because a complex query has a certain syntax, the following characters are reserved for describing the possible queries or the tag-associated values:
  	* *(*
  	* *)*
  	* *:*
  	* *+*
  	* *|*
  	* *!*
Therefore, HybFS does not permit file names containing these characters, due to the complexity of queries.

 # File copy - how can files be copied and their tags be preserved without specifying them in the destination query? Do we need a special tool?
 # The dual operation - on tags and files - raises issues related to tag remove and replace operations
 # Query navigation - how can the query addition be realized if the path addition is done with "/" ? Guess I'll suppose '/' is the same as '+'
 # How should we treat multiple files that have the same name, but different paths? - nevermid that, I just output the entire path.
 # When expecting a descriptive error from an operation, you will get instead a weird one.

