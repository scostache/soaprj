#summary This page presents the design and functionality of HybFS
#labels Phase-Design
#sidebar Contents

<wiki:toc max_depth="3" />

----------------------------------------------------------------------------------------

= HybFS meta-information =

Each file can be described by using one or multiple tags. A tag represents an additional attribute set by the user. The tags can be simple, or have an associated value.

*Simple tags* are specific keywords added to describe a file. The *attribute-value* tags  are used to granulate even more the description. In this case, the attribute represents the criteria of description and the value is the subcategory. 
Ex: _the file_ *photo1.jpg* _can have as simple tags_ *holiday* _and_ *ski* _, and as attribute-value tags_ *year:2005* _,_ *author:stefania* _and_ *type:jpeg*.

To find the file from the above example, we can specify a path that can be a combination of *holiday* or/and *ski*. To further differentiate between the results of this query, we can also mention the value *2005* for the tag *year* .

In order for the user to have also a hierarchic view, all files in the HybFS have 2 special attribute-value tags:
  * path:file_path (file path without the filename)
  * filename:file_name (the exact file name as in the hierarchic file system)

----------------------------------------------------------------------------------------

= HybFS semantics =

The navigation in HybFS resembles the navigation through a normal hierarchic file system, except the path is in fact a *query* on the tag information associated with the files. From the application point of view, the file system operations remain unchanged when using HybFS. 

== Query syntax ==

The queries will support the following logic operators:
  * *+* - logic *AND*
  * *|* - logic *OR*
  * *!* - logic *NOT*

Beside logic operators, brackets can be used for more complicated queries.

Ex: *ls '(type:photo + year:2005) + (!ski + !snowboard)'* - will display all files that have the tag *type:photo* and *year:2005*, but they don't have *ski* and *snowboard* tags.



== HybFS operations ==

Our objective here is to keep the same interface as for the hierarchic file system operations and in the same time to seamlessly add semantic operations.

Concerning *navigation*, the system will be *2-Dimensional*:
  * the current path from the hierarchical file system(s) or:
  * the current virtual folder, which retains the current query

HybFS does not permit file names with *'('* and *')'*, due to complex queries that need brackets. If the path is between brackets, it will be interpreted as a query, otherwise it represents a simple file path relative to the hierarchic file system.



=== File listing ===

All files will be listed based on a query (if a query exists). If there are no semantic queries, the behavior will be the same as in a hierarchic file system.

One of the possible drawbacks of full semantic file systems is that the user doesn't receive any suggestions when navigating through the files and it has to know what is looking for. This was solved by adding virtual folders to refine the results of the navigation. In our example, when we look for files that are *photos* and have been taken in *2005*, we may not know that these files have other tags also and can be filtered even more. Further more, by having this extra information we can discover other files that share the same information/tags as the listed ones. 

Example: 
Suppose that we want to list all files  that have the *type:photo* and *year:2005* tags:
{{{ 
ls '(type:photo + year:2005)'
}}}
The output will be something like:
{{{ 
ski/ holiday/ summer/ photoComposition-2005.jpg 
}}}

where *ski, holiday* and *summer* are virtual directories and *photoComposition-2005.jpg* is a file. Suposing that the file *photoComposition-2005.jpg* has besides these two tags, the keywords _ski, holiday and summer_. Even if they weren't included in the query, they are still listed. 


=== File rename ===

The renaming of files keeps the usual syntax and it can be used also for operations on tags.

Example:
To rename the file *photo1.jpg* as *first_photo.jpg*, one can identify in a unique way the source and the destination by specifing the values for the special tags _path_ and _filename_ : 
{{{
mv '(path:/directory/path + filename:photo1.jpg)' '(path:/directory/path + filename:first_photo.jpg)'
}}}
or it can specify a set of files determined by combinations of tags, to be moved in another directory, and other tags to be assignated:
{{{
mv '(ski + holiday)' '(path:/pictures/alps/ + alps)'
}}}


=== Replace tags ===

This operation is done using the rename operation, but this time applied to tags only. With this operation, all the tags from the files depicted by the source query are removed, new tags being added by specifying them in the destination query. This will tell which are the tags that will replace the original ones.

Example:
For all the files that have the *type:photo* and *author:stefania* tags defined, we want to delete all the other tags and transform the *type:photo* into *type:jpg*. This operation can be done as following:  
{{{
mv '(type:photo + author:stefania + *)' '(type:jpg + author:stefania)'
}}}


=== File remove ===

In order to actually remove a file, you can use a query to point out the files based on tag information. All files resulted from the query will be (phisicaly) deleted along with their tag information from the DB.

=== File creation ===

If someone wants to create a file, than the special tags _path_ and _filename_ must pe specified. Also, to add tags at creation time, they must be specified in a conjunction query.

=== Add/Remove tags ===

This can be done by using the rename operation. Also, the tags can be specified at creation.

-------------------------------------------------------------------------------------------------------------------------------

= Known limitations and issues =

 # Because a complex query has a certain syntax, the following characters are reserved for describing the possible queries or the tag-associated values:
  	* *(*
  	* *)*
  	* *:*
  	* *+*
  	* *|*
  	* *!*

 # File copy - how can files be copied and their tags be preserved without specifying them in the destination query?
 # Query navigation - how can the query addition be realized if the path addition is done with "/" ?
 # Combined query sintax - how can the real path be specified without mentioning the special tags _path_ and _filename_, in an easy way?

